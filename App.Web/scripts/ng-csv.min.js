/*! ng-csv 10-10-2015 */
//!function(a){angular.module("ngCsv.config",[]).value("ngCsv.config",{debug:!0}).config(["$compileProvider",function(a){angular.isDefined(a.urlSanitizationWhitelist)?a.urlSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|data):/):a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|data):/)}]),angular.module("ngCsv.directives",["ngCsv.services"]),angular.module("ngCsv.services",[]),angular.module("ngCsv",["ngCsv.config","ngCsv.services","ngCsv.directives","ngSanitize"]),"undefined"!=typeof module&&"undefined"!=typeof exports&&module.exports===exports&&(module.exports="ngCsv"),angular.module("ngCsv.services").service("CSV",["$q",function(a){var b="\r\n",c="ï»¿",d={"\\t":"	","\\b":"\b","\\v":"","\\f":"\f","\\r":"\r"};this.stringifyField=function(a,b){return"locale"===b.decimalSep&&this.isFloat(a)?a.toLocaleString():"."!==b.decimalSep&&this.isFloat(a)?a.toString().replace(".",b.decimalSep):"string"==typeof a?(a=a.replace(/"/g,'""'),(b.quoteStrings||a.indexOf(",")>-1||a.indexOf("\n")>-1||a.indexOf("\r")>-1)&&(a=b.txtDelim+a+b.txtDelim),a):"boolean"==typeof a?a?"TRUE":"FALSE":a},this.isFloat=function(a){return+a===a&&(!isFinite(a)||Boolean(a%1))},this.stringify=function(d,e){var f=a.defer(),g=this,h="",i="",j=a.when(d).then(function(a){if(angular.isDefined(e.header)&&e.header){var d,j;d=[],angular.forEach(e.header,function(a){this.push(g.stringifyField(a,e))},d),j=d.join(e.fieldSep?e.fieldSep:","),i+=j+b}var k=[];if(angular.isArray(a)?k=a:angular.isFunction(a)&&(k=a()),angular.isDefined(e.label)&&e.label&&"boolean"==typeof e.label){var l,m;l=[],angular.forEach(k[0],function(a,b){this.push(g.stringifyField(b,e))},l),m=l.join(e.fieldSep?e.fieldSep:","),i+=m+b}angular.forEach(k,function(a,c){var d,f,h=angular.copy(k[c]);f=[];var j=e.columnOrder?e.columnOrder:h;angular.forEach(j,function(a){var b=e.columnOrder?h[a]:a;this.push(g.stringifyField(b,e))},f),d=f.join(e.fieldSep?e.fieldSep:","),i+=c<k.length?d+b:d}),e.addByteOrderMarker&&(h+=c),h+=i,f.resolve(h)});return"function"==typeof j["catch"]&&j["catch"](function(a){f.reject(a)}),f.promise},this.isSpecialChar=function(a){return void 0!==d[a]},this.getSpecialChar=function(a){return d[a]}}]),angular.module("ngCsv.directives").directive("ngCsv",["$parse","$q","CSV","$document","$timeout",function(b,c,d,e,f){return{restrict:"AC",scope:{data:"&ngCsv",filename:"@filename",header:"&csvHeader",columnOrder:"&csvColumnOrder",txtDelim:"@textDelimiter",decimalSep:"@decimalSeparator",quoteStrings:"@quoteStrings",fieldSep:"@fieldSeparator",lazyLoad:"@lazyLoad",addByteOrderMarker:"@addBom",ngClick:"&",charset:"@charset",label:"&csvLabel"},controller:["$scope","$element","$attrs","$transclude",function(a,b,e){function f(){var b={txtDelim:a.txtDelim?a.txtDelim:'"',decimalSep:a.decimalSep?a.decimalSep:".",quoteStrings:a.quoteStrings,addByteOrderMarker:a.addByteOrderMarker};return angular.isDefined(e.csvHeader)&&(b.header=a.$eval(a.header)),angular.isDefined(e.csvColumnOrder)&&(b.columnOrder=a.$eval(a.columnOrder)),angular.isDefined(e.csvLabel)&&(b.label=a.$eval(a.label)),b.fieldSep=a.fieldSep?a.fieldSep:",",b.fieldSep=d.isSpecialChar(b.fieldSep)?d.getSpecialChar(b.fieldSep):b.fieldSep,b}a.csv="",angular.isDefined(a.lazyLoad)&&"true"==a.lazyLoad||angular.isArray(a.data)&&a.$watch("data",function(){a.buildCSV()},!0),a.getFilename=function(){return a.filename||"download.csv"},a.buildCSV=function(){var g=c.defer();return b.addClass(e.ngCsvLoadingClass||"ng-csv-loading"),d.stringify(a.data(),f()).then(function(c){a.csv=c,b.removeClass(e.ngCsvLoadingClass||"ng-csv-loading"),g.resolve(c)}),a.$apply(),g.promise}}],link:function(b,c){function d(){var c=b.charset||"utf-8",d=new Blob([b.csv],{type:"text/csv;charset="+c+";"});if(a.navigator.msSaveOrOpenBlob)navigator.msSaveBlob(d,b.getFilename());else{var g=angular.element('<div data-tap-disabled="true"><a></a></div>'),h=angular.element(g.children()[0]);h.attr("href",a.URL.createObjectURL(d)),h.attr("download",b.getFilename()),h.attr("target","_blank"),e.find("body").append(g),f(function(){h[0].click(),h.remove()},null)}}c.bind("click",function(){b.buildCSV().then(function(){d()}),b.$apply()})}}}])}(window,document);
(function (window, document) {

	// Create all modules and define dependencies to make sure they exist
	// and are loaded in the correct order to satisfy dependency injection
	// before all nested files are concatenated by Grunt

	// Config
	angular.module('ngCsv.config', []).
	  value('ngCsv.config', {
	  	debug: true
	  }).
	  config(['$compileProvider', function ($compileProvider) {
	  	if (angular.isDefined($compileProvider.urlSanitizationWhitelist)) {
	  		$compileProvider.urlSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|data):/);
	  	} else {
	  		$compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|data):/);
	  	}
	  }]);

	// Modules
	angular.module('ngCsv.directives', ['ngCsv.services']);
	angular.module('ngCsv.services', []);
	angular.module('ngCsv',
		[
			'ngCsv.config',
			'ngCsv.services',
			'ngCsv.directives',
			'ngSanitize'
		]);

	// Common.js package manager support (e.g. ComponentJS, WebPack)
	if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {
		module.exports = 'ngCsv';
	}
	/**
	 * Created by asafdav on 15/05/14.
	 */
	angular.module('ngCsv.services').
	  service('CSV', ['$q', function ($q) {

	  	var EOL = '\r\n';
	  	var BOM = "\ufeff";

	  	var specialChars = {
	  		'\\t': '\t',
	  		'\\b': '\b',
	  		'\\v': '\v',
	  		'\\f': '\f',
	  		'\\r': '\r'
	  	};

	  	/**
		 * Stringify one field
		 * @param data
		 * @param options
		 * @returns {*}
		 */
	  	this.stringifyField = function (data, options) {
	  		if (options.decimalSep === 'locale' && this.isFloat(data)) {
	  			return data.toLocaleString();
	  		}

	  		if (options.decimalSep !== '.' && this.isFloat(data)) {
	  			return data.toString().replace('.', options.decimalSep);
	  		}

	  		if (typeof data === 'string') {
	  			data = data.replace(/"/g, '""'); // Escape double qoutes

	  			if (options.quoteStrings || data.indexOf(',') > -1 || data.indexOf('\n') > -1 || data.indexOf('\r') > -1) {
	  				data = options.txtDelim + data + options.txtDelim;
	  			}

	  			return data;
	  		}

	  		if (typeof data === 'boolean') {
	  			return data ? 'TRUE' : 'FALSE';
	  		}

	  		return data;
	  	};

	  	/**
		 * Helper function to check if input is float
		 * @param input
		 * @returns {boolean}
		 */
	  	this.isFloat = function (input) {
	  		return +input === input && (!isFinite(input) || Boolean(input % 1));
	  	};

	  	/**
		 * Creates a csv from a data array
		 * @param data
		 * @param options
		 *  * header - Provide the first row (optional)
		 *  * fieldSep - Field separator, default: ',',
		 *  * addByteOrderMarker - Add Byte order mark, default(false)
		 * @param callback
		 */
	  	this.stringify = function (data, options) {
	  		var def = $q.defer();

	  		var that = this;
	  		var csv = "";
	  		var csvContent = !options.sepHeader ? "" : "sep=" + options.fieldSep + EOL;

	  		var dataPromise = $q.when(data).then(function (responseData) {
	  			//responseData = angular.copy(responseData);//moved to row creation
	  			// Check if there's a provided header array
	  			if (angular.isDefined(options.header) && options.header) {
	  				var encodingArray, headerString;

	  				encodingArray = [];
	  				angular.forEach(options.header, function (title, key) {
	  					this.push(that.stringifyField(title, options));
	  				}, encodingArray);

	  				headerString = encodingArray.join(options.fieldSep ? options.fieldSep : ",");
	  				csvContent += headerString + EOL;
	  			}

	  			var arrData = [];

	  			if (angular.isArray(responseData)) {
	  				arrData = responseData;
	  			}
	  			else if (angular.isFunction(responseData)) {
	  				arrData = responseData();
	  			}

	  			// Check if using keys as labels
	  			if (angular.isDefined(options.label) && options.label && typeof options.label === 'boolean') {
	  				var labelArray, labelString;

	  				labelArray = [];

	  				var iterator = !!options.columnOrder ? options.columnOrder : arrData[0];
	  				angular.forEach(iterator, function (value, label) {
	  					var val = !!options.columnOrder ? value : label;
	  					this.push(that.stringifyField(val, options));
	  				}, labelArray);
	  				labelString = labelArray.join(options.fieldSep ? options.fieldSep : ",");
	  				csvContent += labelString + EOL;
	  			}

	  			angular.forEach(arrData, function (oldRow, index) {
	  				var row = angular.copy(arrData[index]);
	  				var dataString, infoArray;

	  				infoArray = [];

	  				var iterator = !!options.columnOrder ? options.columnOrder : row;
	  				angular.forEach(iterator, function (field, key) {
	  					var val = !!options.columnOrder ? row[field] : field;
	  					this.push(that.stringifyField(val, options));
	  				}, infoArray);

	  				dataString = infoArray.join(options.fieldSep ? options.fieldSep : ",");
	  				csvContent += index < arrData.length ? dataString + EOL : dataString;
	  			});

	  			// Add BOM if needed
	  			if (options.addByteOrderMarker) {
	  				csv += BOM;
	  			}

	  			// Append the content and resolve.
	  			csv += csvContent;
	  			def.resolve(csv);
	  		});

	  		if (typeof dataPromise['catch'] === 'function') {
	  			dataPromise['catch'](function (err) {
	  				def.reject(err);
	  			});
	  		}

	  		return def.promise;
	  	};

	  	/**
		 * Helper function to check if input is really a special character
		 * @param input
		 * @returns {boolean}
		 */
	  	this.isSpecialChar = function (input) {
	  		return specialChars[input] !== undefined;
	  	};

	  	/**
		 * Helper function to get what the special character was supposed to be
		 * since Angular escapes the first backslash
		 * @param input
		 * @returns {special character string}
		 */
	  	this.getSpecialChar = function (input) {
	  		return specialChars[input];
	  	};


	  }]);
	/**
	 * ng-csv module
	 * Export Javascript's arrays to csv files from the browser
	 *
	 * Author: asafdav - https://github.com/asafdav
	 */
	angular.module('ngCsv.directives').
	  directive('ngCsv', ['$parse', '$q', 'CSV', '$document', '$timeout', function ($parse, $q, CSV, $document, $timeout) {
	  	return {
	  		restrict: 'AC',
	  		scope: {
	  			data: '&ngCsv',
	  			filename: '@filename',
	  			header: '&csvHeader',
	  			columnOrder: '&csvColumnOrder',
	  			txtDelim: '@textDelimiter',
	  			decimalSep: '@decimalSeparator',
	  			quoteStrings: '@quoteStrings',
	  			fieldSep: '@fieldSeparator',
	  			lazyLoad: '@lazyLoad',
	  			addByteOrderMarker: "@addBom",
	  			ngClick: '&',
	  			charset: '@charset',
	  			label: '&csvLabel',
	  			sepHeader: '&sepHeader'
	  		},
	  		controller: [
			  '$scope',
			  '$element',
			  '$attrs',
			  '$transclude',
			  function ($scope, $element, $attrs, $transclude) {
			  	$scope.csv = '';

			  	if (!angular.isDefined($scope.lazyLoad) || $scope.lazyLoad != "true") {
			  		if (angular.isArray($scope.data)) {
			  			$scope.$watch("data", function (newValue) {
			  				$scope.buildCSV();
			  			}, true);
			  		}
			  	}

			  	$scope.getFilename = function () {
			  		return $scope.filename || 'download.csv';
			  	};

			  	function getBuildCsvOptions() {
			  		var options = {
			  			txtDelim: $scope.txtDelim ? $scope.txtDelim : '"',
			  			decimalSep: $scope.decimalSep ? $scope.decimalSep : '.',
			  			quoteStrings: $scope.quoteStrings,
			  			addByteOrderMarker: $scope.addByteOrderMarker
			  		};
			  		if (angular.isDefined($attrs.csvHeader)) options.header = $scope.$eval($scope.header);
			  		if (angular.isDefined($attrs.csvColumnOrder)) options.columnOrder = $scope.$eval($scope.columnOrder);
			  		if (angular.isDefined($attrs.csvLabel)) options.label = $scope.$eval($scope.label);
			  		if (angular.isDefined($attrs.sepHeader)) options.sepHeader = $scope.$eval($scope.sepHeader);

			  		options.fieldSep = $scope.fieldSep ? $scope.fieldSep : ",";

			  		// Replaces any badly formatted special character string with correct special character
			  		options.fieldSep = CSV.isSpecialChar(options.fieldSep) ? CSV.getSpecialChar(options.fieldSep) : options.fieldSep;

			  		return options;
			  	}

			  	/**
				 * Creates the CSV and updates the scope
				 * @returns {*}
				 */
			  	$scope.buildCSV = function () {
			  		var deferred = $q.defer();

			  		$element.addClass($attrs.ngCsvLoadingClass || 'ng-csv-loading');

			  		CSV.stringify($scope.data(), getBuildCsvOptions()).then(function (csv) {
			  			$scope.csv = csv;
			  			$element.removeClass($attrs.ngCsvLoadingClass || 'ng-csv-loading');
			  			deferred.resolve(csv);
			  		});
			  		$scope.$apply(); // Old angular support

			  		return deferred.promise;
			  	};
			  }
	  		],
	  		link: function (scope, element, attrs) {
	  			function doClick() {
	  				var charset = scope.charset || "utf-8";
	  				var blob = new Blob([scope.csv], {
	  					type: "text/csv;charset=" + charset + ";"
	  				});

	  				if (window.navigator.msSaveOrOpenBlob) {
	  					navigator.msSaveBlob(blob, scope.getFilename());
	  				} else {

	  					var downloadContainer = angular.element('<div data-tap-disabled="true"><a></a></div>');
	  					var downloadLink = angular.element(downloadContainer.children()[0]);
	  					downloadLink.attr('href', window.URL.createObjectURL(blob));
	  					downloadLink.attr('download', scope.getFilename());
	  					downloadLink.attr('target', '_blank');

	  					$document.find('body').append(downloadContainer);
	  					$timeout(function () {
	  						downloadLink[0].click();
	  						downloadLink.remove();
	  					}, null);
	  				}
	  			}

	  			element.bind('click', function (e) {
	  				scope.buildCSV().then(function (csv) {
	  					doClick();
	  				});
	  				scope.$apply();
	  			});
	  		}
	  	};
	  }]);
})(window, document);